# pycosat way source: https://github.com/ContinuumIO/pycosat/blob/master/examples/sudoku.py
# zchaff way source: http://modelai.gettysburg.edu/2011/clue/SATSolver.py


import json
import sys
import subprocess
import time
from operator import add

def runmini(clauses):
    maxVar = 0
    for clause in clauses:
        for literal in clause:
            maxVar = max(abs(literal), maxVar)
    out = open('query.cnf', 'w')
    print >> out, 'c This DIMACS format CNF file was generated by SATSolver.py'
    print >> out, 'c Do not edit.'
    print >> out, 'p cnf', maxVar, len(clauses)
    for clause in clauses:
        for literal in clause:
            print >> out, literal,
        print >> out, '0'
    out.close();

    process = subprocess.Popen('minisat -cpu-lim=10 query.cnf res.txt', stdout=subprocess.PIPE, shell=True)
    process.wait()
    stdout = process.stdout

    stat_list = []
    for l in stdout:
        if ('restarts:' in l) | ('conflicts' in l) | ('decisions' in l) | ('propagations' in l):
            temp_l = l.split()
            stat_list.append(int(temp_l[2]))
        if ('conflict literals' in l) | ('Memory used' in l) | ('CPU time' in l):
            temp_l = l.split()
            stat_list.append(float(temp_l[3]))

    f = open('res.txt', 'r')
    l = f.readlines()
    f.close()

    if 'I' in l[0]:
        stat_list.insert(0,-1)
        return False, -1, stat_list

    sat = not ('U' in l[0])

    if sat:
        stat_list.insert(0, 1)
    else:
        stat_list.insert(0, 0)

    sol = l[1]
    sol = sol[:-3]
    sol = sol.split(' ')

    sol = map(int, sol)
    return sat, sol, stat_list


def num_rep(lay, row, col, dig):
    """
        Creates a bijection between the set of variables with elements <layer,row,column,digit> and
        the set of natural numbers [1..6561]
    """
    return 729 * (lay - 1) + 81 * (row - 1) + 9 * (col - 1) + dig


def sudoku_3d_clauses():
    """
    Generates constraints (clauses) for the 3D sudoku
    """

    res = []
    # for all cells, ensure that the each cell:
    for lay in range(1, 10):
        for row in range(1, 10):
            for col in range(1, 10):
                # denotes (at least) one of the 9 digits (1 clause)
                res.append([num_rep(lay, row, col, dig) for dig in range(1, 10)])
                # does not denote two different digits at once (36 clauses)
                for dig in range(1, 10):
                    for dig_dif in range(dig + 1, 10):
                        res.append([-num_rep(lay, row, col, dig), -num_rep(lay, row, col, dig_dif)])

    def valid(lay, cells):
        # Ensure the input cells contain different values
        for row, xrow in enumerate(cells):
            for col, xcol in enumerate(cells):
                if row < col:
                    for dig in range(1, 10):
                        res.append([-num_rep(lay, xrow[0], xrow[1], dig), -num_rep(lay, xcol[0], xcol[1], dig)])

    # Ensure rows and columns have distinct values
    for lay in range(1, 10):
        for i in range(1, 10):
            valid(lay, [(i, j) for j in range(1, 10)])
            valid(lay, [(j, i) for j in range(1, 10)])

    # Ensures that no numbers repeat within the same bar, i.e., across layers in the same (row, column) position
    for row in range(1, 10):
        for col in range(1, 10):
            for dig in range(1, 10):
                for lay1 in range(1, 10):
                    for lay2 in range(1, 10):
                        if lay1 == lay2:
                            continue
                        res.append([-num_rep(lay1, row, col, dig), -num_rep(lay2, row, col, dig)])

    # Ensure 3x3 sub-grids "regions" have distinct values
    for lay in range(1, 10):
        for i in 1, 4, 7:
            for j in 1, 4, 7:
                valid(lay, [(i + k % 3, j + k // 3) for k in range(9)])

    return res


def sudoku_9l_clauses():
    """
    Generates constraints (clauses) for the 3D sudoku
    """

    res = []
    # for all cells, ensure that the each cell:
    for lay in range(1, 10):
        for row in range(1, 10):
            for col in range(1, 10):
                # denotes (at least) one of the 9 digits (1 clause)
                res.append([num_rep(lay, row, col, dig) for dig in range(1, 10)])
                # does not denote two different digits at once (36 clauses)
                for dig in range(1, 10):
                    for dig_dif in range(dig + 1, 10):
                        res.append([-num_rep(lay, row, col, dig), -num_rep(lay, row, col, dig_dif)])

    def valid(lay, cells):
        # Ensure the input cells contain different values
        for row, xrow in enumerate(cells):
            for col, xcol in enumerate(cells):
                if row < col:
                    for dig in range(1, 10):
                        res.append([-num_rep(lay, xrow[0], xrow[1], dig), -num_rep(lay, xcol[0], xcol[1], dig)])

    # Ensure rows and columns have distinct values
    for lay in range(1, 10):
        for i in range(1, 10):
            valid(lay, [(i, j) for j in range(1, 10)])
            valid(lay, [(j, i) for j in range(1, 10)])

    # Ensure 3x3 sub-grids "regions" have distinct values
    for lay in range(1, 10):
        for i in 1, 4, 7:
            for j in 1, 4, 7:
                valid(lay, [(i + k % 3, j + k // 3) for k in range(9)])

    return res


def sudoku_1l_clauses():
    """
    Generates constraints (clauses) for the 3D sudoku
    """

    res = []
    # for all cells, ensure that the each cell:
    for lay in range(1, 2):
        for row in range(1, 10):
            for col in range(1, 10):
                # denotes (at least) one of the 9 digits (1 clause)
                res.append([num_rep(lay, row, col, dig) for dig in range(1, 10)])
                # does not denote two different digits at once (36 clauses)
                for dig in range(1, 10):
                    for dig_dif in range(dig + 1, 10):
                        res.append([-num_rep(lay, row, col, dig), -num_rep(lay, row, col, dig_dif)])

    def valid(lay, cells):
        # Ensure the input cells contain different values
        for row, xrow in enumerate(cells):
            for col, xcol in enumerate(cells):
                if row < col:
                    for dig in range(1, 10):
                        res.append([-num_rep(lay, xrow[0], xrow[1], dig), -num_rep(lay, xcol[0], xcol[1], dig)])

    # Ensure rows and columns have distinct values
    for lay in range(1, 2):
        for i in range(1, 10):
            valid(lay, [(i, j) for j in range(1, 10)])
            valid(lay, [(j, i) for j in range(1, 10)])

    # Ensure 3x3 sub-grids "regions" have distinct values
    for lay in range(1, 2):
        for i in 1, 4, 7:
            for j in 1, 4, 7:
                valid(lay, [(i + k % 3, j + k // 3) for k in range(9)])

    return res


def solve3d(grid):
    """
    Solves a 3D sudoku
    """
    clauses = sudoku_3d_clauses()
    for lay in range(1, 10):
        for row in range(1, 10):
            for col in range(1, 10):
                dig = grid[lay - 1][row - 1][col - 1]
                # If there is a given at the particular location, add a unit clause to the KB with the corresponding
                # constraint
                if dig > 0:
                    clauses.insert(0,[num_rep(lay, row, col, dig)])


     # Executes minisat solver
    sat, sol, stat = runmini(clauses)

    return stat


def solve9l(grid):
    """
    Solves a 3D sudoku
    """
    clauses = sudoku_9l_clauses()
    for lay in range(1, 10):
        for row in range(1, 10):
            for col in range(1, 10):
                dig = grid[lay - 1][row - 1][col - 1]
                # If there is a given at the particular location, add a unit clause to the KB with the corresponding
                # constraint
                if dig > 0:
                    clauses.insert(0,[num_rep(lay, row, col, dig)])

     # Executes minisat solver
    sat, sol, stat = runmini(clauses)

    return stat


def solve1l(grid, lay_num):
    """
    Solves a 3D sudoku
    """
    clauses = sudoku_9l_clauses()

    lay = lay_num
    for row in range(1, 10):
        for col in range(1, 10):
            dig = grid[lay - 1][row - 1][col - 1]
            # If there is a given at the particular location, add a unit clause to the KB with the corresponding
            # constraint
            if dig > 0:
                clauses.insert(0,[num_rep(lay, row, col, dig)])

     # Executes minisat solver
    sat, sol, stat = runmini(clauses)

    return stat


def sudoku_str_2_list(sud_str, n):
    sud_list = [[0 for x in range(n)] for x in range(n)]
    for row in range(n):
        for col in range(n):
            sud_list[row][col] = int(sud_str[n * row + col])
    return sud_list


def check_3d_cube(curr_cube):
    # Bar constraint
    for row in range(1, 10):
        for col in range(1, 10):
            s = 0
            for lay in range(1, 10):
                s += curr_cube[lay - 1][row - 1][col - 1]
            assert s == 45

    # Row constraint
    for lay in range(1, 10):
        for col in range(1, 10):
            s = 0
            for row in range(1, 10):
                s += curr_cube[lay - 1][row - 1][col - 1]
            assert s == 45

    # Column constraint
    for lay in range(1, 10):
        for row in range(1, 10):
            s = 0
            for col in range(1, 10):
                s += curr_cube[lay - 1][row - 1][col - 1]
            assert s == 45

    # Box constraint
    for lay in range(1, 10):
        for i in 1, 4, 7:
            for j in 1, 4, 7:
                s = 0
                for k in range(9):
                    s += curr_cube[lay - 1][i + k % 3 - 1][j + k // 3 - 1]
                assert s == 45

    print('All constraints satisfied')


if __name__ == '__main__':

    with open('3d-puzzles.json', 'r+') as f:
        data = json.load(f)

    # Creates a list of cubes
    cube_list = [[] for x in range(len(data) / 9)]
    for id in range(len(data)):
        x = data[id]
        p = x['puzzle']
        cube_list[id // 9].append(sudoku_str_2_list(p, 9))

    stat_3d = []
    stat_9l = []
    stat_1l = []

    # Argument of range refers to the number of cubes you want to solve
    for cube in range(len(cube_list)):
        # Saves partial results every 100 cubes
        if cube % 100 == 0:
            sys.stdout = open('output.txt', 'w')
            print('Cube: ' + str(cube))
            print(stat_3d)
            print(stat_9l)
            print(stat_1l)


        stat = solve3d(cube_list[cube])
        stat_3d.append(stat)

        stat = solve9l(cube_list[cube])
        stat_9l.append(stat)

        acum_stat = [0, 0, 0, 0, 0, 0, 0]
        for lay_num in range(1,10):
            stat = solve1l(cube_list[cube], lay_num)
            acum_stat = map(add, acum_stat, stat)

        acum_stat[0] /= 9.0
        acum_stat[-2] /= 9.0
        stat_1l.append(acum_stat)

    # Saves final results
    sys.stdout = open('output.txt', 'w')
    print('Cube: ' + str(cube))
    print(stat_3d)
    print(stat_9l)
    print(stat_1l)


